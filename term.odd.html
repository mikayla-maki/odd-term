<!DOCTYPE html>
<html>

<head>
</head>

<body id="content"
    style="background-color: black; font-family: monospace; color: white; margin: 20vh 20vw; font-size: 18px; overflow-wrap: anywhere;">

</body>
<script type="module">
    import * as odd from "./odd.esm.min.js";
    import {commands} from "./bin.js";
    // terminal: Add line wrapping to 'program_print' and cursor
    // shell: glob expansion
    // Demo: Actually integrating odd

    class History {
        constructor() {
            this.history = [];
            this.cursor = 0;
        }

        get length() {
            return this.history.length;
        }

        reset() {
            this.cursor = this.length;
        }

        push(program) {
            if (program.trim() == "") {
                return;
            }

            this.history.push(program);
        }

        canNavigate() {
            return this.cursor != this.length;
        }

        navigateBackwards() {
            this.cursor = saturating_sub(this.cursor, 1);
        }

        navigateForwards() {
            this.cursor = saturating_add(this.cursor, 1, this.length);
        }

        current() {
            if (this.cursor == this.length) {
                return [];
            } else {
                return this.history[this.cursor].split("");
            }
        }
    }

    console.dir(odd);

    const content = document.getElementById("content");
    let buffer = [];
    let cursor = 0
    let prompt_element = document.createElement("span");
    let buffer_element = document.createElement("span");
    let cursor_container = null;
    let cursor_spacer = null;
    let cursor_element = null;

    let program = null;

    let history = new History();

    function make_cursors() {
        cursor_container = document.createElement("span");
        cursor_spacer = document.createElement("span");
        cursor_element = document.createElement("span");
        cursor_container.append(cursor_spacer, cursor_element);
        cursor_element.append("\xa0");
        cursor_container.style.position = "absolute";
        cursor_element.style.backgroundColor = "white";
        cursor_element.style.zIndex = 0;
        cursor_element.style.opacity = 0.5;
    }


    function flush_edit_buffer() {
        buffer_element.innerHTML = process_text(buffer.join(""));

        let cursor_spaces = "";
        for (var i = 0; i < cursor; i++) {
            cursor_spaces += "\xa0";
        }
        for (var i = 0; i < prompt_text().length; i++) {
            cursor_spaces += "\xa0";
        }

        cursor_spacer.innerHTML = cursor_spaces
    }

    function process_text(text) {
        return text.replace(" ", "\xa0");
    }

    function write_edit_buffer(text) {
        let length = text.length;
        let text_array = text.split("")
        for (var i = 0; i < text_array.length; i++) {
            buffer.splice(cursor + i, 0, text_array[i]);
        }
        cursor += length;
        flush_edit_buffer();
    }

    function backspace() {
        if (cursor > 0) {
            cursor -= 1;
            buffer.splice(cursor, 1);
        }
        console.dir(buffer);
        flush_edit_buffer();
    }

    const context = {
        cwd: [],
        user: null
    };

    function prompt_text() {
        let result = ""
        if (context.user) {
            result += "@" + context.user;
        }
        return result + context.cwd.join("/") + " > ";
    }

    function prompt() {
        prompt_element.innerHTML = process_text(prompt_text())
    }

    function make_sys() {
        return {print, println, context}
    }

    function arg_split(argv_string) {
        let argv = []
        let literal_char = null;
        let arg = "";
        for (let i = 0; i < argv_string.length; i++) {
            let char = argv_string[i];

            if (!literal_char && char == " ") {
                if (arg != "") {
                    argv.push(arg);
                }
                arg = ""
                continue;
            }
            if (!literal_char && (char == "\"" || char == "\'")) {
                literal_char = char
                continue;
            }
            if (literal_char && char == literal_char) {
                literal_char = null
                continue;
            }

            arg += char;
        }
        if (arg.trim() != "") {
          argv.push(arg);
        }

        return argv
    }

    function parse_programs(program_buffer) {
        let cur_program = ""
        let programs = [];
        for (let i = 0; i < program_buffer.length; i++) {
            let char = program_buffer[i];

            if (char == ">") {
                let program = {
                    argv: arg_split(cur_program),
                    stdout: "",
                    stdin: null,
                };
                let file_name = "";

                for (let j = i + 1; j < program_buffer.length; j++) {
                    i = j;
                    if (char == " ") {
                        break;
                    } else {
                        file_name += program_buffer[j]
                    }
                }
                program.stdout = file_name.trim();
                programs.push(program);
                cur_program = "";
                continue;
            }

            cur_program += char;
        }

        if (cur_program != "") {
            programs.push({
                argv: arg_split(cur_program),
                stdout: null,
                stdin: null
            })
        }

        return programs;
    }

    async function enter(commands) {
        let command = [...buffer];
        buffer = [];
        cursor = 0;
        cursor_container.innerHTML = "";
        content.append(document.createElement("br"));

        history.push(command.join(""));
        history.reset();

        let programs = parse_programs(command)
        console.dir(programs);
        for (const program of programs) {
            await commands.invoke(program, make_sys());
        }

        make_cursors();
        prompt_element = document.createElement("span");
        buffer_element = document.createElement("span");
        prompt();
        flush_edit_buffer();
        content.append(cursor_container, prompt_element, buffer_element);
    }

    function saturating_sub(a, b) {
        let result = a - b;
        if (result < 0) {
            return 0;
        } else {
            return result;
        }
    }

    function wrapping_sub(a, b, wrap) {
        let result = a - b;
        if (result < 0) {
            return wrap;
        } else {
            return result;
        }
    }

    function saturating_add(a, b, limit) {
        let result = a + b;
        if (result > limit) {
            return limit;
        } else {
            return result;
        }
    }

    function navigateHistory(history, cb) {
        if (history.canNavigate() || buffer.join("").trim().length == 0) {
            cb(history);

            buffer = history.current();
            cursor = buffer.length;

            flush_edit_buffer();
        }
    }

    content.addEventListener("keydown", async (event) => {
        event.preventDefault();
        console.log(event.code);

        if (event.code == "ArrowUp") {
            return navigateHistory(history, (history) => history.navigateBackwards());
        } else if (event.code == "ArrowDown") {
            return navigateHistory(history, (history) => history.navigateForwards());
        } else {
            history.reset();
        }

        switch (event.code) {
            case "Enter":
                await enter(commands);
                break;
            case "Backspace":
                backspace();
                break;
            case "ArrowLeft":
                cursor = saturating_sub(cursor, 1)
                flush_edit_buffer();
                break;
            case "ArrowRight":
                cursor = saturating_add(cursor, 1, buffer.length);
                flush_edit_buffer();
                break;
            case "Tab":
            case "OSLeft":
            case "AltLeft":
            case "ShiftLeft":
            case "ControlLeft":
            case "OSRight":
            case "AltRight":
            case "ShiftRight":
            case "ControlRight":
                break;
            default:
                write_edit_buffer(event.key)
        }
    })

    function print(text) {
        // TODO: Support new lines
        if (typeof text == "string") {
            content.append(process_text(text));
        } else {
            content.append(text);
        }
    }
    function println(text) {
        print(text);
        content.append(document.createElement("br"));
    }

    await Promise.all(commands.on_startup_programs.map((program) => program(make_sys())))

    make_cursors()
    buffer_element.style.zIndex = 1;
    content.append(cursor_container, prompt_element, buffer_element);
    prompt();
    flush_edit_buffer();

</script>

</html>
